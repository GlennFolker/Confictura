import arc.files.*
import arc.struct.*
import arc.util.*
import arc.util.io.*
import arc.util.serialization.*

import java.nio.charset.*
import java.util.regex.*

buildscript{
    dependencies{
        classpath "com.github.Anuken.Arc:arc-core:$arcVersion"
    }

    repositories{
        mavenCentral()
        maven{url 'https://oss.sonatype.org/content/repositories/snapshots/'}
        maven{url 'https://oss.sonatype.org/content/repositories/releases/'}
        maven{url 'https://raw.githubusercontent.com/Zelaux/MindustryRepo/master/repository'}
        maven{url 'https://jitpack.io'}
    }
}

plugins{
    // Register `EntityAnno` plugin, but only apply on `rootProject`.
    id 'java-library'
    id 'com.github.GlennFolker.EntityAnno' version "$entVersion" apply false
}

def localProps = {
    def props = new StringMap()

    def local = rootProject.layout.projectDirectory.file('local.properties').asFile
    if(local.exists()){
        logger.log(LogLevel.LIFECYCLE, 'Found local.properties file.')
        try(def reader = new FileReader(local, StandardCharsets.UTF_8)){
            PropertiesUtils.load(props, reader)
        }
    }

    props
}()

configure(allprojects){
    apply plugin: 'java-library'
    sourceSets.main.java.srcDirs = [layout.projectDirectory.dir('src')]

    ext{
        for(def prop : localProps){
            ext."$prop.key" = prop.value
        }

        useJitpack = Boolean.valueOf(mindustryBE)
        isDev = project.hasProperty('mod.dev') && Boolean.valueOf(project.property('mod.dev') as String)

        arc = {String module ->
            "com.github.Anuken.Arc$module:$arcVersion"
        }

        mindustry = {String module ->
            "com.github.Anuken.Mindustry$module:$mindustryVersion"
        }

        gltfrenzy = {
            "com.github.GlennFolker:glTFrenzy:$glTFrenzyVersion"
        }
    }

    configurations.configureEach{
        // Resolve the correct Mindustry dependency, and force Arc version.
        resolutionStrategy.eachDependency{
            if(useJitpack && requested.group == 'com.github.Anuken.Mindustry'){
                useTarget "com.github.Anuken.MindustryJitpack:$requested.module.name:$mindustryBEVersion"
            }

            if(requested.group == 'com.github.Anuken.Arc'){
                useVersion arcVersion
            }
        }
    }

    dependencies{
        // Downgrade Java 9+ syntax into being available in Java 8.
        annotationProcessor "com.github.GlennFolker.EntityAnno:downgrader:$entVersion"
    }

    repositories{
        // Necessary Maven repositories to pull dependencies from.
        mavenCentral()
        maven{url 'https://oss.sonatype.org/content/repositories/snapshots/'}
        maven{url 'https://oss.sonatype.org/content/repositories/releases/'}

        // Use Zelaux's non-buggy repository for release Mindustry and Arc builds.
        if(!useJitpack) maven{url 'https://raw.githubusercontent.com/Zelaux/MindustryRepo/master/repository'}
        maven{url 'https://jitpack.io'}
    }

    tasks.withType(JavaCompile).configureEach{
        // Use Java 17+ syntax, but target Java 8 bytecode version.
        sourceCompatibility = 17
        options.release = 8
        options.compilerArgs << '-Xlint:-options'

        options.incremental = true
        options.encoding = 'UTF-8'
    }
}

configure(project(':proc')){
    dependencies{
        implementation rootProject

        implementation "${mindustry(':core')}"
        implementation "${arc(':arc-core')}"
        implementation "${arc(':natives-desktop')}"
    }

    task fetchFiles{
        def out = layout.buildDirectory.dir('fetched')
        def cache = out.map{it.file('cache.txt')}

        outputs.dir out
        outputs.upToDateWhen{
            def c = cache.get().asFile
            c.exists() && c.text == (useJitpack ? mindustryBEVersion : mindustryVersion)
        }

        doFirst{
            def dir = out.get().asFile
            dir.deleteDir()
            dir.mkdirs()

            def exec = Threads.executor('Confictura-Fetcher', OS.cores)
            [
                ['assets/scripts/global.js', 'scripts/global.js'],
                ['assets-raw/sprites/blocks/environment/edge-stencil.png', 'sprites/vanilla/edge-stencil.png']
            ].forEach{file -> exec.submit{
                def src = file[0]
                def dst = file[1] ?: src
                Http.get("https://raw.githubusercontent.com/Anuken/${useJitpack ? 'MindustryJitpack' : 'Mindustry'}/${useJitpack ? mindustryBEVersion : mindustryVersion}/core/$src")
                    .timeout(0)
                    .error{Log.err(it)}
                    .block{res ->
                        def target = new File(dir, dst)
                        target.parentFile.mkdirs()
                        target.withOutputStream{Streams.copy(res.resultAsStream, it)}
                    }
            }}
            Threads.await(exec)

            def c = cache.get().asFile
            c.text = useJitpack ? mindustryBEVersion : mindustryVersion
        }
    }

    task run(type: JavaExec, dependsOn: configurations.runtimeClasspath){
        def assets = rootProject.layout.projectDirectory.dir('assets')
        def out = assets.dir('sprites')
        def colors = assets.dir('meta').dir('confictura').file('block-colors.json')
        def raw = assets.dir('sprites-raw')

        inputs.files raw, tasks.fetchFiles
        outputs.dir out
        outputs.file colors

        outputs.upToDateWhen{false}

        mainClass = 'confictura.proc.ConficturaProc'
        classpath = sourceSets.main.runtimeClasspath
        workingDir = temporaryDir
        standardInput = System.in
        args assets.asFile

        doFirst{
            def dir = out.asFile
            dir.deleteDir()
            dir.mkdirs()

            colors.asFile.delete()

            temporaryDir.deleteDir()
            temporaryDir.mkdirs()

            copy{
                from files(raw)
                into new File(temporaryDir, 'sprites')
            }

            copy{
                from files(tasks.fetchFiles)
                into temporaryDir
                exclude 'cache.txt'
            }
        }

        doLast{
            copy{
                from files(new File(temporaryDir, 'sprites'))
                into out.asFile
                exclude 'vanilla/**'
            }
        }
    }
}

// Apply `EntityAnno` plugin to integrate the annotation processors.
apply plugin: 'com.github.GlennFolker.EntityAnno'

entityAnno{
    modName = property('modName')
    mindustryVersion = property(useJitpack ? 'mindustryBEVersion' : 'mindustryVersion')
    isJitpack = useJitpack
    revisionDir = layout.projectDirectory.dir('revisions').asFile
    fetchPackage = modFetch
    genSrcPackage = modGenSrc
    genPackage = modGen
}

dependencies{
    // Use the entity generation annotation processor.
    compileOnly "com.github.GlennFolker.EntityAnno:entity:$entVersion"
    kapt "com.github.GlennFolker.EntityAnno:entity:$entVersion"

    // Depend on Mindustry/Arc classpath.
    compileOnly "${mindustry(':core')}"
    compileOnly "${arc(':arc-core')}"

    // Depend on glTFrenzy.
    api "${gltfrenzy()}"
}

task list{
    inputs.files tasks.compileJava, configurations.runtimeClasspath

    def output = layout.projectDirectory.dir('assets').dir('meta').dir('confictura').file('classes.json').asFile
    outputs.file output

    doFirst{
        output.parentFile.mkdirs()
        def packages = Jval.newArray()
        def classes = Jval.newArray()

        def forbid = Pattern.compile('\\$\\d+|.+Impl')
        def proc = {def proc, String path, File dir ->
            for(def child : dir.listFiles()){
                if(child.directory){
                    def name = child.name
                    if(!path.startsWith('confictura') && name != 'confictura') continue

                    def visited = path.empty ? name : "$path.$name"
                    if(visited == modFetch || visited == modGenSrc) continue

                    packages.add(visited)
                    proc(proc, visited, child)
                }else{
                    def dot = child.name.lastIndexOf('.')
                    if(dot == -1) continue

                    def name = child.name.substring(0, dot)
                    def ext = child.name.substring(dot + 1)

                    if(ext == 'class' && !forbid.matcher(name).find()) classes.add("$path.$name")
                }
            }
        }

        sourceSets.main.runtimeClasspath.forEach{proc(proc, '', it)}

        def compacted = Jval.newObject().put('packages', packages).put('classes', classes)
        output.withWriter{compacted.writeTo(it, Jval.Jformat.formatted)}
    }
}

clean{
    def assets = layout.projectDirectory.dir('assets')
    delete assets.dir('meta')
    delete assets.dir('sprites')
}

jar{
    inputs.files tasks.list
    archiveFileName = 'base.jar'
}

task deploy(type: Jar){
    inputs.files tasks.list
    mustRunAfter project(':proc').tasks.run

    if(!layout.projectDirectory.dir('assets').dir('sprites').asFile.exists()){
        logger.log(LogLevel.LIFECYCLE, 'Sprites folder not found; automatically running `:proc:run`.')
        inputs.files project(':proc').tasks.run
    }

    archiveFileName = "${modArtifact}Desktop.jar"

    from files(sourceSets.main.output.classesDirs)
    from files(sourceSets.main.output.resourcesDir)
    from configurations.runtimeClasspath.collect{it.isDirectory() ? it : zipTree(it)}

    from files(layout.projectDirectory.dir('assets')){exclude 'sprites-raw/**'}
    from layout.projectDirectory.file('icon.png')

    metaInf{
        from layout.projectDirectory.file('LICENSE')
    }

    def meta = new File(temporaryDir, 'mod.json')
    from meta

    if(!isDev) exclude '**/**Impl*'
    doFirst{
        logger.log(LogLevel.LIFECYCLE, "Building ${isDev ? 'developer' : 'user'} artifact.")

        def map = layout.projectDirectory.file('mod.json').asFile
            .withReader{Jval.read(it)}
            .put('name', modName)
        meta.withWriter{map.writeTo(it, Jval.Jformat.formatted)}
    }
}

task dex(type: Jar){
    inputs.files tasks.deploy
    archiveFileName = "${modArtifact}.jar"

    final def desktopJar = tasks.deploy.archiveFile
    final def dexJar = new File(temporaryDir, 'Dex.jar')

    from zipTree(desktopJar), zipTree(dexJar)
    doFirst{
        // Find Android SDK root.
        def sdkRoot = file(
            System.getenv('ANDROID_SDK_ROOT') ?: System.getenv('ANDROID_HOME') ?:
            { throw new GradleException('Neither `ANDROID_SDK_ROOT` nor `ANDROID_HOME` is set') }
        )

        // Find `d8`.
        def d8 = new File(sdkRoot, "build-tools/$androidBuildVersion/${OS.isWindows ? 'd8.bat' : 'd8'}")
        if(!d8.exists()){
            throw new GradleException("Android SDK `build-tools;$androidBuildVersion` isn't installed or is corrupted")
        }

        // Initialize a release build.
        def input = desktopJar.get().asFile
        def command = "$d8 --release --min-api $androidMinVersion --output $dexJar $input"

        // Include all compile and runtime classpath.
        (configurations.compileClasspath.asList() + configurations.runtimeClasspath.asList()).forEach{
            if(it.exists()) command = "$command --classpath $it"
        }

        // Include Android platform as library.
        def androidJar = new File(sdkRoot, "platforms/android-$androidSdkVersion/android.jar")
        if(!androidJar.exists()){
            throw new GradleException("Android SDK `platforms;android-$androidSdkVersion` isn't installed or is corrupted")
        }

        command = "$command --lib $androidJar"
        if(OS.isWindows) command = "cmd /c $command"

        // Run `d8`.
        logger.log(LogLevel.LIFECYCLE, 'Running `d8`.')
        command.execute(null, layout.projectDirectory.asFile).waitForProcessOutput(System.out, System.err)
    }
}

task install{
    inputs.files tasks.deploy
    doLast{
        def folder = Fi.get(OS.getAppDataDirectoryString('Mindustry')).child('mods')
        folder.mkdirs()

        folder.child(tasks.deploy.archiveFileName.get()).delete()
        folder.child(tasks.dex.archiveFileName.get()).delete()

        new Fi(tasks.deploy.archiveFile.get().asFile).copyTo(folder)
        logger.log(LogLevel.LIFECYCLE, "Copied :deploy output to $folder.")
    }
}
